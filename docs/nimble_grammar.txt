identifier ::= [_a-zA-Z][_a-zA-Z0-9]*

immediate ::= 0 ['b' | 'B'][0-1]+
	| 0 ['x' | 'X'][a-fA-F0-9]+
	| [0-7]+
	| ['-']?[8-9][0-9]*('.'[0-9]*)?

keyword ::= 'break' | 'continue' | 'elif' | 'else' | 'end' | 'endif' | 'goto' | 'if' | 'set' | 'while'

literal ::= '\"' .* '\"' | .* ';' | .*\n

mode :: '&'

modifier ::= '$'

operator_arithmetic ::= '+' | '-' | '*' | '/' | '%'

operator_equivalence ::= '==' | '!=' | '<' | '>' | '<=' | '>='

operator_bitwise ::= '&' | '|' | '^'

operator_logical ::= '>>' | '<<' | '&&' | '||'

operator_unary ::= '-' | '~' | '!'

redirect_input ::= '<'

redirect_output ::= '>' | '>&' | '>!' | '>&!' | '>>' | '>>&'

redirect_pipe ::= '|'

symbol ::= '=' | ':' | ';' | '(' | ')'

---

#
# command -[options] [arguments] < input file > output file 
# ---
# >	Redirect standard output
# >&	Redirect standard output and standard error
# <	Redirect standard input
# >!	Redirect standard output; overwrite file if it exists
# >&!	Redirect standard output and standard error; overwrite file if it exists
# |	Redirect standard output to another command (pipe)
# >>	Append standard output
# >>&	Append standard output and standard error
#

statement ::= <assignment> | <builtin> | <command> | <comment> | <directive> | <label>

assignment ::= <assignment_list>

assignment_define ::= 'set' <identifier> '=' ((<modifier> <identifier>) | <immediate> | <literal>)

assignment_list ::= <assignment_define> (';' <assignment>)*

builtin ::= 'break' 
	| 'continue'
	| 'goto' ((<modifier> <identifier>) | <immediate>)

command ::= <command_0> <mode>?

command_0 ::= <command_1> <command_0p>*

command_0p ::= <<redirect_input>> <command_1> <command_0p>*

command_1 ::= <command_2> <command_1p>*

command_1p ::= <redirect_output> <command_2> <command_1p>*

command_2 ::= <command_3> <command_2p>*

command_2p ::= <redirect_pipe> <command_3> <command_2p>*

command_3 ::= '(' <command_0> ')'
	| <command_call_list>
	| <modifier> <identifier>

command_call ::= <literal> <argument_list>

command_call_list ::= <command_call> (';' <command_call_list>)*

comment ::= '#'.*\n

directive ::= <directive_if> | <directive_while>

directive_elif ::= 'elif' '(' <expression> ')' <statement>*

directive_else ::= 'else' <statement>*

directive_if ::= 'if' '(' <expression> ')' <statement>* <directive_elif>* <directive_else>? 'endif'

directive_while ::= 'while' '(' <expression> ')' <statement>* 'end'

expression ::= 

label ::= <identifier ':'
